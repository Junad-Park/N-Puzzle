import random, math


class NPuzzle:
    

    def __init__(self, N, puzzle=None, moves=0, previous=None):
        self.__N = N
        self.__n = int(math.sqrt(N))
        self.__goal = [ _ for _ in range(1, N)] + [0]
        if puzzle is None:
            self.__puzzle = self.__goal
        else:
            self.__puzzle = puzzle
        self.__moves = moves
        self.previous = previous

    def is_goal(self):
        return self.__puzzle == self.__goal

    def get_f(self):
        """ get f

        Returns:
            _type_: _description_
        """
        return self.get_g() + self.get_h()

    def get_g(self):
        """ get_g

        Returns:
            _type_: _description_
        """
        return self.__moves

    def get_h(self):
        """ get_h

        Returns:
            _type_: _description_
        """
        h = 0
        for i in range(len(self.__goal)):
            if self.__goal[i] != 0:
                if self.__puzzle[i] != self.__goal[i]:
                    h+=1
        return h

    def clone(self):
        """
            returns copy of the current board with
                moves = current moves + 1 and
                previous = current board
        """
        return NPuzzle(self.__N, self.__puzzle.copy(), self.__moves + 1, self)

    def to_pq_entry(self, count):
        """
            returns the tuple (priority, count, board)
        """
        return (self.get_f(), count, self)

    def move_blank(self, where):
        """
            where: Move blank 'left', 'right',
                    'up', or 'down',
                   Does nothing if the move is out-of-bounds.
        """
        zero_idx = self.__puzzle.index(0)
        if where == 'up':
            if zero_idx >= self.__n:
                change_elemnt = self.__puzzle[zero_idx]
                self.__puzzle[zero_idx] = self.__puzzle[zero_idx-self.__n]
                self.__puzzle[zero_idx-self.__n] = change_elemnt

        if where == 'down':
            if zero_idx < (self.__N-self.__n):
                change_elemnt = self.__puzzle[zero_idx]
                self.__puzzle[zero_idx] = self.__puzzle[zero_idx+self.__n]
                self.__puzzle[zero_idx+self.__n] = change_elemnt

        if where == 'right':
            if zero_idx%self.__n != (self.__n-1):
                change_elemnt = self.__puzzle[zero_idx]
                self.__puzzle[zero_idx] = self.__puzzle[zero_idx+1]
                self.__puzzle[zero_idx+1] = change_elemnt

        if where == 'left':
            if zero_idx%self.__n != 0:
                change_elemnt = self.__puzzle[zero_idx]
                self.__puzzle[zero_idx] = self.__puzzle[zero_idx-1]
                self.__puzzle[zero_idx-1] = change_elemnt
        
    def neighbours(self):
        """
            returns a list of all valid neighbours generated by moving
                the blank tile once in all possible directions
        """
        zero_idx = self.__puzzle.index(0)

        neighbours = []
        
        # up?
        if (zero_idx//self.__n) != 0:
            new_board = self.clone()
            new_board.move_blank('up')
            neighbours.append(new_board)

        # down?
        if (zero_idx//self.__n) != self.__n-1:
            new_board = self.clone()
            new_board.move_blank('down')
            neighbours.append(new_board)

        # right?
        if zero_idx%self.__n != (self.__n-1):
            new_board = self.clone()
            new_board.move_blank('right')
            neighbours.append(new_board)

        # Can we move blank tile left?
        if zero_idx%self.__n != 0:
            new_board = self.clone()
            new_board.move_blank('left')
            neighbours.append(new_board)
        return neighbours

    def get_previous_states(self):
        """
            return a list of previous states by going up the state space tree
        """
        states = [self]
        prev = self.previous
        while prev is not None:
            states.append(prev)
            prev = prev.previous

        states.reverse()
        return states

    def getRandomPuzzle(self) -> list[int]:
        """ Get random puzzle based on self.goal
        
        Returns:
            list[int]: The shuffle of the self.goal.copy
        """
        temp_puzzle = self.__goal.copy()
        random.shuffle(temp_puzzle)
        return temp_puzzle

    def createSolvablePuzzle(self) -> list[int]:
        """ Create solvable puzzle 
        
        Returns:
            list[int]: solvable puzzle
        """
        while True:
            random_puzzle = self.getRandomPuzzle()
            row_from_bottom = self.__n - (random_puzzle.index(0)//self.__n)
            if self.isSolved(row_from_bottom, random_puzzle):
                break
        self.__puzzle = random_puzzle
        #[1,2,3,4,5,6,7,0,8]
        #[1,2,3,4,5,6,7,8,9,10,11,12,13,14,0,15]
        return self.__puzzle
  
    def isSolved(self, row, random_puzzle) -> bool:
        """ Decide it can be solved
        
        Args:
            row (int): row of puzzle from bottom
            puzzle (list[int]): random puzzle

        Returns:
            list[int]: solvable puzzle
        """
        if (self.__n%2 == 1):
            return self.getInversionCnt(random_puzzle) % 2 == 0
        else:
            if (row%2 == 0):
                return self.getInversionCnt(random_puzzle) % 2 == 1
            else:
                return self.getInversionCnt(random_puzzle) % 2 == 0
  
    def getInversionCnt(self, random_puzzle) -> int:
        """ Get inversion count

        Args:
            random_puzzle (list[int]): random puzzle

        Returns:
            int: inversion count
        """
        inversion_cnt = 0
        for i in range(len(random_puzzle)):
            for j in range(i, len(random_puzzle)): 
                if (random_puzzle[i]!=0 and 
                    random_puzzle[j] != 0 and 
                    random_puzzle[i] > random_puzzle[j]
                    ):
                    inversion_cnt += 1
        return inversion_cnt

    def moveUp(self) -> bool:
        """ Swap zero, above element in puzzle 

        Returns:
            bool: Can move up
        """
        copy_puzzle = self.getPuzzle()
        zero_idx = copy_puzzle.index(0)
        if zero_idx < self.__n:
            print(f"{zero_idx} < {self.__n}")
            return False
        
        change_elemnt = copy_puzzle[zero_idx]
        copy_puzzle[zero_idx] = copy_puzzle[zero_idx-self.__n]
        copy_puzzle[zero_idx-self.__n] = change_elemnt
        return copy_puzzle

    def moveDown(self) -> bool:
        """ Swap zero, bottom element in puzzle 

        Returns:
            bool: Can move down
        """
        copy_puzzle = self.getPuzzle()
        zero_idx = copy_puzzle.index(0)
        if zero_idx >= (self.__N-self.__n):
            print(f"{zero_idx} >= {self.__N-self.__n}")
            return False
    
        change_elemnt = copy_puzzle[zero_idx]
        copy_puzzle[zero_idx] = copy_puzzle[zero_idx+self.__n]
        copy_puzzle[zero_idx+self.__n] = change_elemnt
        return copy_puzzle

    def moveRight(self) -> bool:
        """ Swap zero, right element in puzzle 

        Returns:
            bool: Can move right
        """
        copy_puzzle = self.getPuzzle()
        zero_idx = copy_puzzle.index(0)
        if zero_idx%self.__n == (self.__n-1):
            print(f"{zero_idx%self.__n} == {self.__n-1}")
            return False
      
        change_elemnt = copy_puzzle[zero_idx]
        copy_puzzle[zero_idx] = copy_puzzle[zero_idx+1]
        copy_puzzle[zero_idx+1] = change_elemnt
        return copy_puzzle

    def moveLeft(self) -> bool:
        """ Swap zero, left element in puzzle 

        Returns:
            bool: Can move left
        """
        copy_puzzle = self.getPuzzle()
        zero_idx = copy_puzzle.index(0)
        if zero_idx%self.__n == 0:
            print(f"{zero_idx%self.__n} == {0}")
            return False
      
        change_elemnt = copy_puzzle[zero_idx]
        copy_puzzle[zero_idx] =copy_puzzle[zero_idx-1]
        copy_puzzle[zero_idx-1] = change_elemnt
        return copy_puzzle

    def display(self) -> None:
        """ Output in 2D

        Returns:
            None
        """
        for i in range(self.__n):
            for j in range(self.__n):
                print(f"{self.__puzzle[i*self.__n+j]:<3}", end="")
            print()
        print()

    def getPuzzle(self) -> list[int]:
        """ Return self.__puzzle """
        return self.__puzzle

    def getGoal(self) -> list[int]:
        """ Return self.__goal """
        return self.__goal
    
    def getN(self) -> int:
        """ Return self.__N """
        return self.__N

    def getn(self) -> int:
        """ Return self.__n """
        return self.__n

    def setN(self, N):
        """ Set self.__N """
        self.__N = N

    def setn(self, n):
        """ Set self.__n """
        self.__n = n
    
    def setGoal(self):
        """ Set self.__goal """
        self.__goal = [ _ for _ in range(1, self.__N)] + [0]
    
    def setPuzzle(self):
        """ Set self.__puzzle """
        self.__puzzle = self.__goal
    
    def updatePuzzle(self, N):
        """ Set all member variables """
        n = int(math.sqrt(N))
        self.setN(N)
        self.setn(n)
        self.setGoal()
        self.setPuzzle()

    def getPrevious(self):
        return self.previous

    def __eq__(self, other):
        """
            check if self == other
        """
        if other is None:
            return False
        else:
            return self.__puzzle == other.__puzzle
    
    def __lt__(self, other):
        return self.get_f() < other.get_f()